import os
from concurrent import futures
from loguru import logger
import argparse
import grpc
import sys
import json
from pathlib import Path
import uuid
import logging

TIMEOUT_S = 2

ROLE_PERMISSIONS = {
    "admin": ["*"],  # Admins can access all RPCs
    "client": [
        "/paymentgateway.PaymentGateway/Authenticate",
        "/paymentgateway.PaymentGateway/RegisterClient",
        "/paymentgateway.PaymentGateway/CheckBalance",
        "/paymentgateway.PaymentGateway/Deposit",
        "/paymentgateway.PaymentGateway/Withdraw",
        "/paymentgateway.PaymentGateway/TransferAmount",
        "/paymentgateway.PaymentGateway/GetTransactionHistory"
    ],
    "bank": [
        "/paymentgateway.PaymentGateway/RegisterBank"
    ],
    "auth": [
        "/paymentgateway.PaymentGateway/Authenticate"
    ]
}

active_sessions = {}

# Get the absolute path of the current script
script_dir = Path(__file__).parent

sys.path.append("generated")
import bank_pb2
import bank_pb2_grpc as bank_grpc
import payment_gateway_pb2
import payment_gateway_pb2_grpc as payment_gateway_grpc

# =========================================================================================
# Base code generated by ChatGPT + Modified by me (Prompt 1 in README)
# =========================================================================================
logging.basicConfig(
    filename="./server/logs/payment_gateway_logs.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

class LoggingInterceptor(grpc.ServerInterceptor):
    def intercept_service(self, continuation, handler_call_details):
        handler = continuation(handler_call_details)

        metadata = dict(handler_call_details.invocation_metadata)

        # Extract details
        method_name = handler_call_details.method
        session_token = metadata.get("authorization", "Unknown")
        role, username = active_sessions.get(session_token, ("Unknown", "Unknown"))
        client_ip = metadata.get("ip", "Unknown IP")
        transaction_amount = metadata.get("amount", "N/A")

        logging.info(f"Received request: {method_name}")
        logging.info(f"Session Token: {session_token}, Role: {role}, Username: {username} Client IP: {client_ip}, Transaction Amount: {transaction_amount}")
        
        # =========================================================================================
        # Base code generated by Claude (Prompt 2 in README)
        # =========================================================================================
        def wrapped_handler(request, servicer_context):
            try:
                response = handler.unary_unary(request, servicer_context)
                # Now you can access response attributes
                if hasattr(response, 'err_code') and response.err_code == 1:
                    logging.error(f"Error in response: {response.text if hasattr(response, 'text') else 'No error text'}")
                else:
                    logging.info(f"Reply: {response.text if hasattr(response, 'text') else 'N/A'}")
                return response
            except Exception as e:
                logging.error(f"Error in {method_name}: {str(e)}")
                raise e
            
        # Return a new unary-unary handler with our wrapped function
        return grpc.unary_unary_rpc_method_handler(
            wrapped_handler,
            request_deserializer=handler.request_deserializer,
            response_serializer=handler.response_serializer
        )
# =========================================================================================

class RegisteredClient:
    def __init__(self, username, account_number, password):
        self.username = username
        self.account_number = account_number
        self.password = password
        self.bank_id = None

    def __eq__(self, value):
        if type(value) != type(RegisteredClient):
            raise ValueError("Only two RegisteredClient classes can be compared")
        if self.username == value.username and \
           self.account_number == value.account_number and \
           self.password == value.password:
            return True
        else:
            return False

    def checkPassword(self, password_entered):
        return self.password == password_entered

    def getUsername(self):
        return self.username
    
    def getAccountNumber(self):
        return self.account_number
    
    def getBankId(self):
        return self.bank_id
    
    def setBankId(self, id):
        self.bank_id = id


class RegisteredBank:
    def __init__(self, id, port):
        self.id = id
        self.port = port
        self.registered_clients = []

    def getId(self):
        return self.id
    
    def setId(self, id):
        self.id = id

    def getPort(self):
        return self.port
    
    def setPort(self, port):
        self.port = port
    
    def getAllClients(self):
        return self.registered_clients
    
    def isRegistered(self, client):
        for registered_client in self.getAllClients():
            if registered_client == client:
                return True
        return False

    def addClient(self, username, account_number, password):
        new_client = RegisteredClient(username, account_number, password)
        new_client.setBankId(self.id)
        self.registered_clients.append(new_client)


class PaymentGatewayServicer(payment_gateway_grpc.PaymentGatewayServicer):
    def Authenticate(self, request, context):
        logger.info("Authentication Request Received")
        role = getRole(request.username, request.password)

        if role is not None:
            logger.info(f"User authenticated; role = {role}")
            session_token = str(uuid.uuid4())
            active_sessions[session_token] = (role, request.username)

            # Attach session token to response metadata
            context.send_initial_metadata([("authorization", session_token)])

            return payment_gateway_pb2.AuthResponse(err_code=0, text="", role=role)
        
        logger.error("Authentication failed")
        context.set_code(grpc.StatusCode.UNAUTHENTICATED)
        context.set_details("Invalid credentials")
        return payment_gateway_pb2.AuthResponse(err_code=1, text="Authentication Failed", role="")

    def AdminAccessCreateNewClient(self, request, context):
        logger.info("Create new client request received")
        response_obj = payment_gateway_pb2.CreateNewClientResponse()
        
        # Check if the bank exists
        if not isBankRegistered(request.new_client_bank_id):
            logger.error(f"Invalid bank with bank id = {request.new_client_bank_id}")
            response_obj.err_code = 1
            response_obj.text = f"Invalid bank with bank id = {request.new_client_bank_id}"
            return response_obj
        
        # Check if username already exists
        if isUsernameRegistered(request.new_client_username):
            logger.error(f"Username already taken")
            response_obj.err_code = 1
            response_obj.text = "Username already taken"
            return response_obj
        
        with grpc.insecure_channel(f"localhost:{getBankPortById(bank_id=request.new_client_bank_id)}") as channel:
            bank_stub = bank_grpc.BankStub(channel)

            request_obj = bank_pb2.CreateNewClientRequest()
            request_obj.username = request.new_client_username
            request_obj.password = request.new_client_password
            request_obj.initial_balance = request.initial_balance

            response = bank_stub.CreateNewClient(request_obj, timeout=TIMEOUT_S)
            response_obj.err_code = response.err_code
            response_obj.text = response.text
            response_obj.account_number = response.account_number

            if response.err_code == 1:
                logger.error("Failed to create new client")
            else:
                logger.info("New client successfully created")
                register_client_request = payment_gateway_pb2.RegisterClientRequest()
                register_client_request.username = request.new_client_username
                register_client_request.account_number = response.account_number
                register_client_request.password = request.new_client_password
                register_client_request.bank_id = request.new_client_bank_id
                register_client_response = self.RegisterClient(request=register_client_request, context=context)
                if register_client_response.err_code == 1:
                    logger.error(register_client_response.text)
                else:
                    logger.info("New Client registered successfully")

            return response_obj

    def AdminAccessAddBalance(self, request, context):
        logger.info("Add balance request received")
        response_obj = payment_gateway_pb2.AddBalanceResponse()
        
        client = getClient(request.username)
        if client is None:
            logger.error("Client not registered")
            response_obj.err_code = 1
            response_obj.text = "Client not registered"
            return response_obj
        
        client_bank_id = client.getBankId()
        client_bank_port = getBankPortById(client_bank_id)

        with grpc.insecure_channel(f"localhost:{client_bank_port}") as channel:
            bank_stub = bank_grpc.BankStub(channel)

            response = bank_stub.AddBalance(request, timeout=TIMEOUT_S)

            response_obj = response

            if response.err_code == 1:
                logger.error("Balance not added")
            else:
                logger.info("Balance added successfully")

            return response_obj

    def RegisterClient(self, request, context):
        logger.info("Registration request for client received")
        response_obj = payment_gateway_pb2.RegisterClientResponse()

        if not isBankRegistered(bank_id=request.bank_id):
            response_obj.err_code = 1
            response_obj.text = f"No bank with given bank id"
            logger.error("No bank with given id exists")
            return response_obj
        
        if getClient(username=request.username) is not None:
            response_obj.err_code = 0
            response_obj.text = f"Client {request.username} already registered"
            logger.info(f"Client {request.username} already registered")
            return response_obj
        
        else:
            bank_port = getBankPortById(bank_id=request.bank_id)
            with grpc.insecure_channel(f"localhost:{bank_port}") as channel:
                bank_stub = bank_grpc.BankStub(channel)

                request_obj = bank_pb2.ClientInformationRequest()
                request_obj.account_number = str(request.account_number)
                request_obj.username = str(request.username)
                request_obj.password = str(request.password)

                response = bank_stub.VerifyClientInfo(request_obj, timeout=TIMEOUT_S)

                if response.present:
                    bank = [bank for bank in registered_banks if bank.getId() == request.bank_id][0]
                    bank.addClient(request.username, request.account_number, request.password)
                    response_obj.err_code = 0
                    response_obj.text = f"Client {request.username} registered successfully"
                    logger.info(f"Client {request.username} registered successfully")
                    return response_obj
                else:
                    response_obj.err_code = 1
                    response_obj.text = f"Client {request.username} not registered with bank bank_id = {request.bank_id}"
                    logger.error(f"Client {request.username} not registered with bank bank_id = {request.bank_id}")
                    return response_obj
    
    def RegisterBank(self, request, context):
        logger.info("Registration request for bank received")
        response_obj = payment_gateway_pb2.RegisterBankResponse()
        try:
            if not isBankRegistered(bank_port=request.port):
                if registered_banks == []:
                    new_id = 1
                else:
                    new_id = max([bank.getId() for bank in registered_banks]) + 1
                
                new_bank = RegisteredBank(new_id, request.port)
                registered_banks.append(new_bank)

                response_obj.err_code = 0
                response_obj.text = "Bank successfully registered"
                response_obj.id = new_id
                logger.info(f"New bank registered successfully with id = {new_id}")
                return response_obj
            else:
                response_obj.err_code = 0
                response_obj.text = f"Bank at port {request.port} already registered"
                for bank in registered_banks:
                    if bank.getPort() == request.port:
                        response_obj.id = bank.getId()
                        break
                logger.info(f"Bank at port {request.port} was already registered")
                return response_obj
        except Exception as e:
            response_obj.err_code = 1
            response_obj.text = f"Exception: {e}"
            logger.error(f"Exception: {e}")
            return response_obj

    def CheckBalance(self, request, context):
        logger.info("Check Balance request received")
        response_obj = payment_gateway_pb2.CheckBalanceResponse()
        
        client = getClient(username=getActiveSessionUsername(context))

        with grpc.insecure_channel(f"localhost:{getBankPortById(client.getBankId())}") as channel:
            bank_stub = bank_grpc.BankStub(channel)

            request_obj = bank_pb2.FetchBalanceRequest()
            request_obj.account_number = client.getAccountNumber()

            response = bank_stub.FetchBalance(request_obj, timeout=TIMEOUT_S)

            if response.err_code == 1:
                logger.error(response.text)
                response_obj.err_code = 1
                response_obj.text = response.text
            else:
                logger.info(f"Balance = {response.balance}")
                response_obj.err_code = 0
                response_obj.balance = response.balance
            
            return response_obj

    def Deposit(self, request, context):
        logger.info("Deposit Request Received")
        username = getActiveSessionUsername(context)
        client = getClient(username)

        with grpc.insecure_channel(f"localhost:{getBankPortById(client.getBankId())}") as channel:
            bank_stub = bank_grpc.BankStub(channel)

            request_obj = bank_pb2.AmountTransferRequest()
            request_obj.receiver_username = username
            request_obj.amount = request.amount
            request_obj.type = "deposit"

            response = bank_stub.Credit(request_obj, timeout=TIMEOUT_S)

            if response.err_code == 1:
                logger.error(response.text)
            else:
                logger.info(f"Deposit successful final balance = {response.balance}")
            
        return response
    
    def Withdraw(self, request, context):
        logger.info("Withdraw Request Received")
        username = getActiveSessionUsername(context)
        client = getClient(username)

        with grpc.insecure_channel(f"localhost:{getBankPortById(client.getBankId())}") as channel:
            bank_stub = bank_grpc.BankStub(channel)

            request_obj = bank_pb2.AmountTransferRequest()
            request_obj.sender_username = username
            request_obj.amount = request.amount
            request_obj.type = "withdraw"

            response = bank_stub.Debit(request_obj, timeout=TIMEOUT_S)

            if response.err_code == 1:
                logger.error(response.text)
            else:
                logger.info(f"Withdrawn successful final balance = {response.balance}")
            
        return response

    def TransferAmount(self, request, context):
        logger.info("Transfer Request Received")
        response_obj = bank_pb2.AmountTransferResponse()

        my_username = getActiveSessionUsername(context)
        my_client_obj = getClient(my_username)

        request_obj = bank_pb2.AmountTransferRequest()
        request_obj.sender_username = my_username
        request_obj.receiver_username = request.receiver_username
        request_obj.sender_bank_id = my_client_obj.getBankId()
        request_obj.receiver_bank_id = request.receiver_bank_id
        request_obj.sender_acc_no = my_client_obj.getAccountNumber()
        request_obj.receiver_acc_no = request.receiver_acc_no
        request_obj.amount = request.amount
        request_obj.type = "transfer"

        final_balance = 0

        # Check if receiver exists
        if not check_client_exist(request.receiver_bank_id, request.receiver_username, request.receiver_acc_no):
            logger.error("Recepient not found")
            response_obj.err_code = 1
            response_obj.text = "Recepient not found"
            return response_obj

        debit_successful = False

        # First debiting the amount
        with grpc.insecure_channel(f"localhost:{getBankPortById(my_client_obj.getBankId())}") as channel:
            bank_stub = bank_grpc.BankStub(channel)

            response = bank_stub.Debit(request_obj, timeout=TIMEOUT_S)

            if response.err_code == 1:
                logger.error(response.text)
                return response
            else:
                debit_successful = True
                logger.info(f"Debited successful final balance = {response.balance}")
                final_balance = response.balance
        
        if debit_successful:
            # First debiting the amount
            with grpc.insecure_channel(f"localhost:{getBankPortById(request.receiver_bank_id)}") as channel:
                bank_stub = bank_grpc.BankStub(channel)

                response = bank_stub.Credit(request_obj, timeout=TIMEOUT_S)

                if response.err_code == 1:
                    logger.error(response.text)
                else:
                    logger.info(f"Credited successful final balance = {response.balance}")
                    response.balance = final_balance
                    return response
        
        # Credit failed, returning money to sender's account
        with grpc.insecure_channel(f"localhost:{getBankPortById(my_client_obj.getBankId())}") as channel:
            bank_stub = bank_grpc.BankStub(channel)
            request_obj.type = "reimbursement"
            response = bank_stub.Debit(request_obj, timeout=TIMEOUT_S)
        response_obj.err_code = 1
        response_obj.text = "Failed to tranfer the money, if any money is debited from your account it should be credited soon."

        return response_obj

    def GetTransactionHistory(self, request, context):
        logger.info("Get transaction history request received")
        
        client = getClient(username=getActiveSessionUsername(context))

        with grpc.insecure_channel(f"localhost:{getBankPortById(client.getBankId())}") as channel:
            bank_stub = bank_grpc.BankStub(channel)

            request_obj = bank_pb2.TransactionsRequest()
            request_obj.username = client.getUsername()

            response = bank_stub.GetTransactions(request_obj, timeout=TIMEOUT_S)

            if response.err_code == 1:
                logger.error(response.text)
            else:
                logger.info(f"Successfully retrieved transaction history")
            
        return response


class AuthenticationInterceptor(grpc.ServerInterceptor):
    def intercept_service(self, continuation, handler_call_details):
        role, _ = getRoleUsername(handler_call_details)

        allowed_methods = ROLE_PERMISSIONS.get(role)
        if "*" not in allowed_methods and handler_call_details.method not in allowed_methods:
            return self._deny_access("Permission denied")
            
        return continuation(handler_call_details)

    def deny_access(self, message):
        def abort(ignored_request, context):
            context.abort(grpc.StatusCode.PERMISSION_DENIED, message)
        return abort


def check_client_exist(bank_id, username, acc_no):
    with grpc.insecure_channel(f"localhost:{getBankPortById(bank_id)}") as channel:
        bank_stub = bank_grpc.BankStub(channel)

        request_obj = bank_pb2.CheckClientExistRequest()
        request_obj.username = username
        request_obj.acc_no = acc_no

        response = bank_stub.CheckClientExist(request_obj, timeout=TIMEOUT_S)

        if response.err_code == 1:
            logger.error(response.text)
            return False
        else:
            logger.info(f"Client {username} in bank {bank_id} exists.")
            return True


def getActiveSessionUsername(context):
    metadata = dict(context.invocation_metadata())
    session_token = metadata.get("authorization")
    role, username = active_sessions.get(session_token, (None, None))
    return username


def getRoleUsername(handler_call_details):
    metadata = dict(handler_call_details.invocation_metadata)
    session_token = metadata.get("authorization")
    if session_token == "auth":
        return "auth", "auth"
    elif session_token == "bank":
        return "bank", "bank"
    role, username = active_sessions.get(session_token, (None, None))
    return role, username


def clear_screen():
    os.system("cls" if os.name == "nt" else "clear")


registered_banks = []

admins = []

def read_admins():
    admin_details_file_realtive_path = "admin_details.json"
    file_path = script_dir / admin_details_file_realtive_path
    with file_path.open("r", encoding="utf-8") as file:
        global admins
        admins = json.load(file)


def getClient(username=None):
    for bank in registered_banks:
        for client in bank.getAllClients():
            if client.getUsername() == username:
                return client
    return None


def isBankRegistered(bank_id=None, bank_port=None):
    if bank_port is None and bank_id is not None:
        for bank in registered_banks:
            if bank.getId() == bank_id:
                return True
    elif bank_id is None and bank_port is not None:
        for bank in registered_banks:
            if bank.getPort() == bank_port:
                return True
    return False


def getBankIdForClient(username=None):
    for bank in registered_banks:
        for client in bank.getAllClients():
            if client.getUsername() == username:
                return bank.getId()
    return -1


def isUsernameRegistered(username=None):
    for bank in registered_banks:
        for client in bank.getAllClients():
            if client.getUsername() == username:
                return True
            
    for admin in admins:
        if admin["username"] == username:
            return True
    return False


def getBankPortById(bank_id=None):
    for bank in registered_banks:
        if bank.getId() == bank_id:
            return bank.getPort()
    return None


def getRole(username, password):
    for bank in registered_banks:
        for client in bank.getAllClients():
            if client.getUsername() == username and client.checkPassword(password):
                return "client"
    for admin in admins:
        if admin["username"] == username and admin["password"] == password:
            return "admin"
    return None


def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10), interceptors=[LoggingInterceptor(), AuthenticationInterceptor()])
    payment_gateway_grpc.add_PaymentGatewayServicer_to_server(PaymentGatewayServicer(), server)
    
    # Secure with SSL/TLS
    private_key_realtive_path = "server.key"
    file_path = script_dir / private_key_realtive_path
    with open(file_path, "rb") as f:
        private_key = f.read()

    certificate_realtive_path = "server.crt"
    file_path = script_dir / certificate_realtive_path
    with open(file_path, "rb") as f:
        certificate_chain = f.read()

    server_credentials = grpc.ssl_server_credentials(
        [(private_key, certificate_chain)]
    )
    server.add_secure_port(f"localhost:{port}", server_credentials)
    
    server.start()
    logger.info(f"Payment Gateway server started at port = {port}")
    server.wait_for_termination()


if __name__ == "__main__":
    logger.remove()
    logger.add(sys.stdout, format="{time:MMMM D, YYYY - HH:mm:ss} {level} --- <level>{message}</level>")

    parser = argparse.ArgumentParser(description="Start the Payment Gateway gRPC Server")
    parser.add_argument("--port", type=int, default=50051, help="Port number to run the gRPC server on")

    args = parser.parse_args()
    
    global port
    port = args.port
    
    clear_screen()
    read_admins()
    serve()